<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ”å‡¡çš„å—è‹¦ä¹‹æ—… (ç½‘é¡µç‰ˆ)</title>
    <style>
        body { background-color: #1e1e1e; color: #d4d4d4; font-family: 'Consolas', 'Courier New', monospace; padding: 20px; }
        #game-container { max-width: 800px; margin: 0 auto; background: #000; padding: 20px; border-radius: 10px; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        #output { height: 400px; overflow-y: auto; white-space: pre-wrap; margin-bottom: 10px; border: 1px solid #333; padding: 10px; }
        #input-area { display: flex; }
        #user-input { flex-grow: 1; background: #333; color: white; border: none; padding: 10px; font-family: inherit; }
        button { background: #007acc; color: white; border: none; padding: 10px 20px; cursor: pointer; }
        button:hover { background: #005f9e; }
        .hp-bar { color: #ff4d4d; }
        .posture-bar { color: #ffa500; }
        .system-msg { color: #4ec9b0; }
        .enemy-msg { color: #ce9178; }
        .danger { color: #ff0000; font-weight: bold; font-size: 1.2em; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="output">ğŸŒŸ æ¬¢è¿æ¥åˆ°ã€ŠğŸ”å‡¡çš„å—è‹¦ä¹‹æ—…ï¼šç½‘é¡µç‰ˆã€‹...<br>æ­£åœ¨åˆå§‹åŒ– DeepSeek å¤§è„‘...</div>
    <div id="input-area">
        <input type="text" id="user-input" placeholder="è¾“å…¥å‘½ä»¤æˆ–èŠå¤©..." autocomplete="off">
        <button onclick="handleInput()">å‘é€</button>
    </div>
    <div style="margin-top:10px; font-size: 0.8em; color: #666;">
        æ“ä½œæŒ‡å—ï¼šè¾“å…¥ 1, 2, 3 é€‰æ‹©èœå•ã€‚<br>
        æˆ˜æ–—ä¸­ï¼šæŒ‰é”®ç›˜ <b>J (æ ¼æŒ¡)</b>, <b>K (æ”»å‡»)</b>, <b>ç©ºæ ¼ (è·³è·ƒ)</b>
    </div>
</div>

<script>
    // ==========================================
    // ğŸ‘‡ ğŸ”å‡¡ï¼ŒæŠŠä½ çš„ DeepSeek Key å¡«åœ¨è¿™é‡Œï¼
    // è­¦å‘Šï¼šç½‘é¡µç‰ˆææ˜“æ³„éœ² Keyï¼Œä¸è¦å‘ç»™é™Œç”Ÿäººï¼
    // ==========================================
    const API_KEY = "sk-540794d8048040d2a06ef5606f05c2a4"; 

    // æ¸¸æˆçŠ¶æ€
    let player = { hp: 100, inventory: [] };
    let gameState = "MENU"; // MENU, BATTLE, CHAT
    let currentNPC = null;
    let chatHistory = [];
    
    // æˆ˜æ–—å˜é‡
    let battleState = null; // waiting, attacking
    let enemy = { name: "", hp: 100, posture: 0, maxPosture: 80 };
    let reactionTimer = null;
    let battleLoopTimer = null;

    const outputDiv = document.getElementById('output');
    const inputField = document.getElementById('user-input');

    // æ—¥å¿—è¾“å‡ºå·¥å…·
    function print(text, className = "") {
        const div = document.createElement('div');
        div.innerHTML = text;
        if (className) div.className = className;
        outputDiv.appendChild(div);
        outputDiv.scrollTop = outputDiv.scrollHeight;
    }

    // åˆå§‹åŒ–èœå•
    function showMenu() {
        gameState = "MENU";
        print("<br>==========================");
        print(`ğŸ’ èƒŒåŒ…: [${player.inventory.join(', ') || 'ç©º'}] | â¤ï¸ HP: ${player.hp}`);
        print("1. ğŸŒ² å»æ£®æ—æ‰¾è™ (å³æ—¶æˆ˜æ–—)");
        print("2. ğŸ˜ï¸ åœ¨æ‘å­é‡Œè½¬è½¬ (æ‰¾AIèŠå¤©)");
        print("3. ğŸ¥ å–è¯å›è¡€");
        print("è¯·åœ¨ä¸‹æ–¹è¾“å…¥æ•°å­—é€‰æ‹©ï¼š", "system-msg");
    }

    // å¤„ç†ç”¨æˆ·è¾“å…¥
    function handleInput() {
        const text = inputField.value.trim();
        inputField.value = "";
        if (!text) return;

        print(`> ${text}`, "system-msg");

        if (gameState === "MENU") {
            if (text === "1") startBattle();
            else if (text === "2") startChatSelection();
            else if (text === "3") { player.hp = 100; print("âœ¨ æ»¡è¡€å¤æ´»ï¼"); showMenu(); }
            else print("âŒ è¾“é”™å•¦ï¼Œç¬¨è›‹ï¼");
        } else if (gameState === "CHAT_SELECT") {
            selectNPC(text);
        } else if (gameState === "CHAT") {
            if (['bye', '88', 'quit'].includes(text.toLowerCase())) {
                print(`${currentNPC.name}: 886ã€‚`);
                showMenu();
            } else {
                sendToAI(text);
            }
        }
    }

    // ç»‘å®šå›è½¦é”®
    inputField.addEventListener("keydown", (e) => {
        if (e.key === "Enter") handleInput();
    });

    // ================= æˆ˜æ–—ç³»ç»Ÿ (JSç‰ˆ) =================
    
    // ç›‘å¬é”®ç›˜æŒ‰é”® (æˆ˜æ–—ç”¨)
    document.addEventListener("keydown", (e) => {
        if (gameState !== "BATTLE") return;
        const key = e.key.toLowerCase();
        
        if (battleState && battleState.active) {
            clearTimeout(reactionTimer);
            battleState.active = false; // ç»“ç®—å®Œæ¯•
            
            let dmg = 15;
            if (battleState.type === "fast") dmg = 20;

            if (battleState.type === "idle") {
                if (key === "k") {
                    print(`ğŸ—¡ï¸ å·è¢­æˆåŠŸï¼é€ æˆ 15 ç‚¹ä¼¤å®³ï¼`);
                    enemy.hp -= 15; enemy.posture += 10;
                } else {
                    print("ğŸƒ ä½ åœ¨å¹²å˜›ï¼Ÿé”™å¤±è‰¯æœºï¼");
                }
            } else if (battleState.type === "attack" || battleState.type === "fast") {
                if (key === "j") {
                    print("âœ¨ é”µï¼å®Œç¾å¼¹åï¼");
                    enemy.posture += (battleState.type === "normal" ? 10 : 20);
                } else {
                    print(`ğŸ©¸ æ ¼æŒ¡å¤±è´¥ï¼ä½ è¢«ç äº†ï¼ HP -${dmg}`, "danger");
                    player.hp -= dmg;
                }
            } else if (battleState.type === "danger") {
                if (key === " ") {
                    print("ğŸ’¨ å®Œç¾è¯†ç ´ï¼è¸©å¤´ï¼");
                    enemy.posture += 40;
                } else {
                    print("ğŸ©¸ ä¸‹æ®µæ”»å‡»ä¸èƒ½æŒ¡ï¼ HP -30", "danger");
                    player.hp -= 30;
                }
            }
            checkBattleEnd();
        }
    });

    function startBattle() {
        gameState = "BATTLE";
        enemy = { name: "æ‹¿ç€è‘±çš„å“¥å¸ƒæ—", hp: 100, posture: 0, maxPosture: 80 };
        print(`<br>ğŸ‘¹ é­é‡å¼ºæ•Œï¼š${enemy.name}ï¼`, "danger");
        print("ğŸ® å‡†å¤‡å¥½é”®ç›˜ï¼J=æ ¼æŒ¡, K=æ”»å‡», ç©ºæ ¼=è·³è·ƒ");
        
        // å¼€å§‹æˆ˜æ–—å¾ªç¯
        nextBattleTurn();
    }

    function nextBattleTurn() {
        if (player.hp <= 0 || enemy.hp <= 0 || enemy.posture >= enemy.maxPosture) return;

        let waitTime = Math.random() * 1000 + 1000; // 1-2ç§’åå‡ºæ‹›
        battleLoopTimer = setTimeout(() => {
            if (gameState !== "BATTLE") return;
            
            const actions = ['attack', 'fast', 'danger', 'idle'];
            const action = actions[Math.floor(Math.random() * actions.length)];
            let reactionTime = 1000;
            
            battleState = { active: true, type: action };

            if (action === "idle") {
                print(`\nğŸ‘€ ${enemy.name} å‘å‘†ä¸­... (æŒ‰ K å·è¢­!)`);
                reactionTime = 1200;
            } else if (action === "attack") {
                print(`\nğŸ—¡ï¸ ${enemy.name} åŠˆç ! (æŒ‰ J æ ¼æŒ¡)`);
                reactionTime = 900;
            } else if (action === "fast") {
                print(`\nâš¡ æé€Ÿè¿æ–©! (å¿«æŒ‰ J!)`);
                reactionTime = 500;
            } else if (action === "danger") {
                print(`\nğŸ”´ ã€å±ã€‘ ä¸‹æ®µæ‰«å‡»! (æŒ‰ ç©ºæ ¼ è·³è·ƒ)`, "danger");
                reactionTime = 800;
            }

            // å€’è®¡æ—¶ï¼Œå¦‚æœç©å®¶æ²¡ååº”
            reactionTimer = setTimeout(() => {
                if (battleState.active) {
                    battleState.active = false;
                    if (action !== "idle") {
                        print("ğŸ©¸ ååº”å¤ªæ…¢ï¼ç›´æ¥å‘½ä¸­ï¼ HP -15", "danger");
                        player.hp -= 15;
                    } else {
                        print("ğŸƒ é”™å¤±è‰¯æœºã€‚");
                    }
                    checkBattleEnd();
                }
            }, reactionTime);

        }, waitTime);
    }

    function checkBattleEnd() {
        // æ›´æ–°UI
        print(`â¤ï¸ HP: ${player.hp} | ğŸ›¡ï¸ æ•Œäººèº¯å¹²: ${"â–ˆ".repeat(enemy.posture/5)}`, "hp-bar");

        if (player.hp <= 0) {
            print("ğŸ’€ æ­»ã€‚ (ä½ å¤ªå¼±å°äº†)", "danger");
            setTimeout(showMenu, 2000);
        } else if (enemy.hp <= 0 || enemy.posture >= enemy.maxPosture) {
            print("ğŸ’¥ å¿æ€ï¼æˆ˜æ–—èƒœåˆ©ï¼");
            player.inventory.push("åŠæ ¹è‘±");
            setTimeout(showMenu, 2000);
        } else {
            nextBattleTurn();
        }
    }

    // ================= NPC ç³»ç»Ÿ (AI) =================
    
    const npcs = [
        { name: "å¥¸å•†", persona: "è´ªè´¢ï¼Œçœ‹ä¸èµ·ç©·äººã€‚" },
        { name: "å°‘å¥³Gemini", persona: "å‚²å¨‡ï¼Œæ¯’èˆŒï¼Œçˆ±éª‚äººå¤ªå¼±å°ã€‚" }
    ];

    function startChatSelection() {
        gameState = "CHAT_SELECT";
        print("<br>ä½ æƒ³æ‰¾è°ï¼Ÿ");
        npcs.forEach((n, i) => print(`${i+1}. ${n.name}`));
    }

    function selectNPC(index) {
        const i = parseInt(index) - 1;
        if (npcs[i]) {
            currentNPC = npcs[i];
            gameState = "CHAT";
            chatHistory = [
                { role: "system", content: `ä½ æ‰®æ¼”RPG NPCï¼š${currentNPC.name}ã€‚æ€§æ ¼ï¼š${currentNPC.persona}ã€‚èƒŒåŒ…ï¼š${player.inventory.join(',')}ã€‚ç®€çŸ­å›å¤ã€‚` }
            ];
            print(`ğŸ’¬ å¼€å§‹ä¸ ${currentNPC.name} å¯¹è¯ (è¾“å…¥ bye é€€å‡º)...`, "system-msg");
            print(`(${currentNPC.name} æ­£åœ¨æ‰“é‡ä½ ...)`);
        } else {
            print("âŒ é€‰é”™äº†ï¼");
            showMenu();
        }
    }

    async function sendToAI(text) {
        chatHistory.push({ role: "user", content: text });
        print("â³ AI æ€è€ƒä¸­...", "system-msg");

        try {
            const response = await fetch("https://api.deepseek.com/chat/completions", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${API_KEY}`
                },
                body: JSON.stringify({
                    model: "deepseek-chat",
                    messages: chatHistory,
                    stream: false
                })
            });

            const data = await response.json();
            if (data.error) throw new Error(data.error.message);
            
            const reply = data.choices[0].message.content;
            print(`ğŸ—£ï¸ ${currentNPC.name}: ${reply}`, "enemy-msg");
            chatHistory.push({ role: "assistant", content: reply });

        } catch (error) {
            print(`âš ï¸ æŠ¥é”™å•¦: ${error.message}`, "danger");
        }
    }

    // å¯åŠ¨
    showMenu();

</script>
</body>
</html>